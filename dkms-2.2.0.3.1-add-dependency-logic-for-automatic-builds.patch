--- dkms-2.2.0.3.1/dkms.8.autodeplogic~	2014-03-07 02:11:03.673511411 +0100
+++ dkms-2.2.0.3.1/dkms.8	2014-03-07 02:11:03.679511671 +0100
@@ -871,6 +871,14 @@ on
 .B dkms_autoinstaller
 for more information.
 .TP
+.B BUILD_DEPENDS[#]=
+This optional directive is an array that allows you to specify other modules as
+dependencies for your module. Each array element should be the
+.B PACKAGE_NAME
+of another module that is managed by dkms. Do not specify a version or
+architecture in the dependency. Note that this directive is only advisory;
+missing or broken dependencies cause non-fatal warnings.
+.TP
 .B BUILD_EXCLUSIVE_KERNEL=
 This optional directive allows you to specify a regular expression which defines
 the subset of kernels which DKMS is allowed to build your module for.  If the kernel
--- dkms-2.2.0.3.1/dkms.autodeplogic~	2014-03-07 02:11:03.671511325 +0100
+++ dkms-2.2.0.3.1/dkms	2014-03-07 02:11:03.678511628 +0100
@@ -3,6 +3,7 @@
 #  Dynamic Kernel Module Support (DKMS) <dkms-devel@dell.com>
 #  Copyright (C) 2003-2008 Dell, Inc.
 #  by Gary Lerhaupt, Matt Domsch, & Mario Limonciello
+#  Copyright (C) 2012 by Darik Horn <dajhorn@vanadac.com>
 #
 #    This program is free software; you can redistribute it and/or modify
 #    it under the terms of the GNU General Public License as published by
@@ -3281,7 +3282,12 @@ make_kmp()
 # by hand if dkms_autoinstaller is not used.
 autoinstall() {
     local status mv mvka m v k a last_v last_m tenative
+    local install_count next_depends
     local -a to_install=()
+    local -a next_install=()
+    local -a installed_modules=()
+    local -A build_depends=()
+
     # Walk through our list of installed and built modules, and create
     # a list of modules that need to be reinstalled.
     while read status mvka; do
@@ -3298,7 +3304,10 @@ autoinstall() {
         elif [[ $last_m != $m ]]; then
             last_m="$m"
             last_v='0'
-            [[ $tenative ]] && to_install[${#to_install[@]}]="$tenative"
+            if [[ $tenative ]]; then
+                to_install[${#to_install[@]}]="$tenative"
+                build_depends["$m"]="${BUILD_DEPENDS[@]}"
+            fi
             tenative=''
         fi
         if [[ ($(VER $v) > $(VER $last_v)) ]]; then
@@ -3308,14 +3317,50 @@ autoinstall() {
     done < <(module_status)
     # We may have exited the loop with $tenative set.  If it is,
     # it contains something that should be updated.
-    [[ $tenative ]] && to_install[${#to_install[@]}]="$tenative"
+    if [[ $tenative ]]; then
+        to_install[${#to_install[@]}]="$tenative"
+        build_depends["$m"]="${BUILD_DEPENDS[@]}"
+    fi
     [[ $to_install ]] || return 0
-    # Install modules that need to be updated in parallel.
-    for mv in "${to_install[@]}"; do
-        IFS=/ read m v <<< "$mv"
-        (module="$m"; module_version="$v"; install_module) &
-    done
-    wait
+
+	while true; do
+		install_count=0
+		next_install=( )
+
+		# Step 1: Install modules that have an empty depdendency list.
+		for mv in "${to_install[@]}"; do
+			IFS=/ read m v <<< "$mv"
+			if [[ -z "${build_depends[$m]}" ]]; then
+				(module="$m"; module_version="$v"; install_module) &
+				installed_modules[${#installed_modules[@]}]="$m"
+				install_count=$(($install_count +1))
+			else
+				next_install[${#next_install[@]}]="$mv"
+			fi
+		done
+
+		wait
+
+		# Step 2: Keep going if at least one module was installed during
+		# this iteration.
+		[[ "$install_count" -gt 0 ]] || break;
+
+		# Step 3: Remove modules that were installed during Step 1 from
+		# the dependency lists of all other modules.
+		for m in ${!build_depends[@]}; do
+			for d in ${build_depends[$m]}; do
+				for i in ${installed_modules}; do
+					[[ "$d" = "$i" ]] && break 2
+				done
+				next_depends+="$d "
+			done
+			build_depends[$m]="${next_depends%% }"
+		done
+
+		# Step 4: Remove modules that were installed during Step 1 from
+		# the job queue.
+		to_install=( "${next_install[@]}" )
+	done
 }
 
 function make_redhat3_driver_disk ()
